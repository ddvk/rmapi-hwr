// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// SolverConfiguration SolverConfiguration
//
// swagger:model SolverConfiguration
type SolverConfiguration struct {

	// math.solver.angle-unit
	// Enum: [deg rad]
	AngleUnit string `json:"angle-unit,omitempty"`

	// math.solver.decimal-separator
	DecimalSeparator string `json:"decimal-separator,omitempty"`

	// math.solver.enable
	Enable bool `json:"enable,omitempty"`

	// math.solver.fraction-mode
	// Enum: [decimal rational mixed]
	FractionMode string `json:"fraction-mode,omitempty"`

	// math.solver.fractional-part-digits
	FractionalPartDigits int32 `json:"fractional-part-digits,omitempty"`

	// math.solver.options
	// Enum: [algebraic numeric]
	Options string `json:"options,omitempty"`

	// math.solver.rounding-mode
	// Enum: [half up truncate]
	RoundingMode string `json:"rounding-mode,omitempty"`
}

// Validate validates this solver configuration
func (m *SolverConfiguration) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAngleUnit(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFractionMode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOptions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRoundingMode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var solverConfigurationTypeAngleUnitPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["deg","rad"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		solverConfigurationTypeAngleUnitPropEnum = append(solverConfigurationTypeAngleUnitPropEnum, v)
	}
}

const (

	// SolverConfigurationAngleUnitDeg captures enum value "deg"
	SolverConfigurationAngleUnitDeg string = "deg"

	// SolverConfigurationAngleUnitRad captures enum value "rad"
	SolverConfigurationAngleUnitRad string = "rad"
)

// prop value enum
func (m *SolverConfiguration) validateAngleUnitEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, solverConfigurationTypeAngleUnitPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *SolverConfiguration) validateAngleUnit(formats strfmt.Registry) error {

	if swag.IsZero(m.AngleUnit) { // not required
		return nil
	}

	// value enum
	if err := m.validateAngleUnitEnum("angle-unit", "body", m.AngleUnit); err != nil {
		return err
	}

	return nil
}

var solverConfigurationTypeFractionModePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["decimal","rational","mixed"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		solverConfigurationTypeFractionModePropEnum = append(solverConfigurationTypeFractionModePropEnum, v)
	}
}

const (

	// SolverConfigurationFractionModeDecimal captures enum value "decimal"
	SolverConfigurationFractionModeDecimal string = "decimal"

	// SolverConfigurationFractionModeRational captures enum value "rational"
	SolverConfigurationFractionModeRational string = "rational"

	// SolverConfigurationFractionModeMixed captures enum value "mixed"
	SolverConfigurationFractionModeMixed string = "mixed"
)

// prop value enum
func (m *SolverConfiguration) validateFractionModeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, solverConfigurationTypeFractionModePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *SolverConfiguration) validateFractionMode(formats strfmt.Registry) error {

	if swag.IsZero(m.FractionMode) { // not required
		return nil
	}

	// value enum
	if err := m.validateFractionModeEnum("fraction-mode", "body", m.FractionMode); err != nil {
		return err
	}

	return nil
}

var solverConfigurationTypeOptionsPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["algebraic","numeric"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		solverConfigurationTypeOptionsPropEnum = append(solverConfigurationTypeOptionsPropEnum, v)
	}
}

const (

	// SolverConfigurationOptionsAlgebraic captures enum value "algebraic"
	SolverConfigurationOptionsAlgebraic string = "algebraic"

	// SolverConfigurationOptionsNumeric captures enum value "numeric"
	SolverConfigurationOptionsNumeric string = "numeric"
)

// prop value enum
func (m *SolverConfiguration) validateOptionsEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, solverConfigurationTypeOptionsPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *SolverConfiguration) validateOptions(formats strfmt.Registry) error {

	if swag.IsZero(m.Options) { // not required
		return nil
	}

	// value enum
	if err := m.validateOptionsEnum("options", "body", m.Options); err != nil {
		return err
	}

	return nil
}

var solverConfigurationTypeRoundingModePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["half up","truncate"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		solverConfigurationTypeRoundingModePropEnum = append(solverConfigurationTypeRoundingModePropEnum, v)
	}
}

const (

	// SolverConfigurationRoundingModeHalfUp captures enum value "half up"
	SolverConfigurationRoundingModeHalfUp string = "half up"

	// SolverConfigurationRoundingModeTruncate captures enum value "truncate"
	SolverConfigurationRoundingModeTruncate string = "truncate"
)

// prop value enum
func (m *SolverConfiguration) validateRoundingModeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, solverConfigurationTypeRoundingModePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *SolverConfiguration) validateRoundingMode(formats strfmt.Registry) error {

	if swag.IsZero(m.RoundingMode) { // not required
		return nil
	}

	// value enum
	if err := m.validateRoundingModeEnum("rounding-mode", "body", m.RoundingMode); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SolverConfiguration) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SolverConfiguration) UnmarshalBinary(b []byte) error {
	var res SolverConfiguration
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
